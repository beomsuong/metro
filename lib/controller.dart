import 'dart:async';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import 'model.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'controller.g.dart';

class ApiService {
  final Dio dio = Dio();
  final String baseUrl =
      'http://swopenAPI.seoul.go.kr/api/subway/${dotenv.env['API_KEY']}/json/realtimeStationArrival/0/5/';

  Future<Autogenerated> fetchRealtimeArrival(String stationName) async {
    final response = await dio.get('$baseUrl$stationName');

    if (response.statusCode == 200) {
      return Autogenerated.fromJson(response.data);
    } else {
      throw Exception('Failed to load data');
    }
  }
}

@riverpod
class RealtimeArrivalNotifier extends _$RealtimeArrivalNotifier {
  final ApiService apiService = ApiService();

  Timer? _timer;
  double progress = 0.0;
  int remainingTime = 5;
  bool timerState = false;
  String? selectedBtrainNo;

  @override
  AsyncValue<Autogenerated> build() => const AsyncValue.loading();

  Future<void> fetchData(String stationName) async {
    try {
      state = const AsyncValue.loading();
      final arrivals = await apiService.fetchRealtimeArrival(stationName);
      timerState = false;
      timeStartStop(stationName);
      arrivals.realtimeArrivalList!.sort((a, b) {
        if (selectedBtrainNo != null) {
          if (a.btrainNo == selectedBtrainNo) return -1;
          if (b.btrainNo == selectedBtrainNo) return 1;
        }
        return a.subwayId!.compareTo(b.subwayId.toString());
      });
      state = AsyncValue.data(arrivals);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }

  void setBtrainNo(String id) {
    selectedBtrainNo = id;
    state.value!.realtimeArrivalList!.sort((a, b) {
      if (selectedBtrainNo != null) {
        if (a.btrainNo == selectedBtrainNo) return -1;
        if (b.btrainNo == selectedBtrainNo) return 1;
      }
      return a.subwayId!.compareTo(b.subwayId.toString());
    });
    state = state.whenData((data) => data);
  }

  ///타이머 시작 정지
  void timeStartStop(String stationName) {
    progress = 0.0;
    remainingTime = 500;
    if (timerState) {
      _timer?.cancel();
      timerState = false;
      return;
    }
    timerState = true;
    _timer?.cancel();
    _timer = Timer.periodic(const Duration(milliseconds: 10), (timer) {
      if (remainingTime > 0) {
        remainingTime--;
        progress = (1 - remainingTime / 500);
      } else {
        progress = 0.0;
        remainingTime = 500;
        fetchData(stationName);
      }

      ///UI 다시 그림
      state = state.whenData((data) => data);
    });
  }
}
